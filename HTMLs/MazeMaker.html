<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Try solve the maze: Complex Maze Maker & Solver ðŸ§©</title>
    <style>
        /* --- Base & Responsiveness Setup --- */
        
        :root {
            /* Define a max size for the maze container to be used in JS and CSS */
            --max-maze-dim: 95vmin;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 10px;
            color: #333;
            min-height: 100vh;
            margin: 0;
            /* REMOVED touch-action: manipulation; to allow native scrolling/zooming */
        }
        
        h1 {
            color: #1a2a6c;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
            margin-top: 10px;
            margin-bottom: 15px;
            font-size: clamp(24px, 5vw, 36px);
        }
        
        /* --- Controls Section --- */
        
        #controls {
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
            gap: 15px;
            /* Reduced gap for smaller screens */
            justify-content: center;
            align-items: center;
            padding: 15px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 95vw;
        }
        
        label {
            font-weight: 600;
        }
        
        button,
        select {
            padding: 10px 15px;
            font-size: 14px;
            /* Slightly smaller font for responsiveness */
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
            min-width: 120px;
            /* Ensure buttons are large enough on touch devices */
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        #generate-button {
            background-color: #2ECC71;
            color: white;
        }
        
        #generate-button:hover {
            background-color: #27AE60;
        }
        
        #solve-button {
            background-color: #3498DB;
            color: white;
        }
        
        #solve-button:hover {
            background-color: #2980B9;
        }
        
        #difficulty {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
        
        /* Media query for larger screens (e.g., desktops) to use more space */
        @media (min-width: 768px) {
            #controls {
                gap: 20px;
                padding: 20px;
            }
            
            button,
            select {
                font-size: 16px;
                min-width: 150px;
            }
        }
        
        /* --- Maze Container --- */
        
        #maze-container {
            border: 8px solid #333;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            background-color: white;
            display: grid;
            /* Use a variable for maximum dimension */
            max-width: var(--max-maze-dim);
            max-height: var(--max-maze-dim);
            width: auto;
            /* Will be set by JS */
            height: auto;
            /* Will be set by JS */
            /* Prevents selection during drag */
            user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            /* REMOVED touch-action: none; to allow two-finger zoom/pan */
        }
        
        /* --- Cell Styles (Aesthetics) --- */
        
        .cell {
            box-sizing: border-box;
            background-color: #333;
            /* Wall */
            transition: background-color 0.1s ease;
            /* Ensure smooth visual updates */
        }
        
        .path {
            background-color: white;
        }
        
        .start {
            background-color: #f39c12;
            /* Deep Orange/Start */
        }
        
        .end {
            background-color: #e74c3c;
            /* Dark Red/End */
        }
        
        .explored {
            background-color: #f1c40f;
            /* Yellow/Gold for exploration */
        }
        
        .user-path {
            background-color: #2c3e50;
            /* Dark Blue/Navy for user-driven path */
        }
        
        .solution {
            background-color: #1abc9c;
            /* Turquoise/Green for final shortest path */
            animation: pulse 0.8s infinite alternate;
        }
        
        @keyframes pulse {
            from {
                opacity: 1;
            }
            
            to {
                opacity: 0.8;
            }
        }
        
        /* --- Win Modal Styles --- */
        
        #win-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .win-modal-content {
            background: #ffffff;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
            transform: scale(0.8);
            opacity: 0;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        
        #win-modal-overlay.active .win-modal-content {
            transform: scale(1);
            opacity: 1;
        }
        
        #win-modal-overlay.active {
            display: flex;
        }
        
        .win-modal-content h2 {
            color: #2ECC71;
            margin-top: 0;
            font-size: 28px;
        }
        
        .win-modal-content p {
            font-size: 18px;
            color: #555;
            margin-bottom: 25px;
        }
        
        #close-modal-btn {
            background-color: #3498DB;
            color: white;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
        }
        
        #close-modal-btn:hover {
            background-color: #2980B9;
        }
    </style>
    
    <!-- Vercel Web Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</head>

<body>
    <h1>Try solve the maze: Complex Maze Maker & Solver ðŸ§©</h1>
    
    <div id="controls">
        <label for="difficulty">Difficulty:</label>
        <select id="difficulty">
            <option value="21">Normal (21x21)</option>
            <option value="41">Hard (41x41)</option>
            <option value="81">Insane (81x81)</option>
        </select>
        <button id="generate-button">Generate New Maze</button>
        <button id="solve-button">Solve Maze (BFS)</button>
    </div>
    
    <div id="maze-container">
    </div>
    
    <div id="win-modal-overlay">
        <div class="win-modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <button id="close-modal-btn">Awesome!</button>
        </div>
    </div>
    <script>
        // JAVASCRIPT LOGIC
        
        // --- Configuration (Dynamic) ---
        let ROWS = 21;
        let COLS = 21;
        let GRID_SIZE = 25;
        let mazeGrid = [];
        let isSolving = false;
        let userPath = [];
        let isMouseDown = false;
        let lastCell = null;
        
        // --- Win Messages by Difficulty ---
        const WIN_MESSAGES = {
            21: {
                title: "Victory!",
                message: "You navigated the Normal maze with ease. Great start!"
            },
            41: {
                title: "Brilliant Solve!",
                message: "The Hard maze proved no match for your skills. Ready for the ultimate challenge?"
            },
            81: {
                title: "MAZE MASTER!",
                message: "You conquered the Insane 81x81 maze! This required serious dedication and focus."
            }
        };
        
        // --- Utility Functions ---
        
        function coordsToId(r, c) {
            return r * COLS + c;
        }
        
        /**
         * Calculates the optimal tile size based on the selected grid dimension
         * and the available screen space, ensuring responsiveness.
         */
        function calculateTileSize(size) {
            const root = document.documentElement;
            const style = getComputedStyle(root);
            
            const vminValue = style.getPropertyValue('--max-maze-dim');
            let maxDimension = Math.min(window.innerWidth, window.innerHeight) * (parseFloat(vminValue) / 100);
            
            // Subtract a small buffer for the 8px border on both sides (16px total)
            maxDimension -= 16;
            
            let newSize = Math.floor(maxDimension / size);
            
            // Ensure a minimum size for visibility, especially for 81x81
            return Math.max(newSize, 3);
        }
        
        function initializeGrid() {
            // Reset state
            isSolving = false;
            userPath = [];
            
            const difficultySelect = document.getElementById('difficulty');
            const selectedSize = parseInt(difficultySelect.value);
            
            ROWS = selectedSize;
            COLS = selectedSize;
            
            // Calculate size based on current viewport for responsiveness
            GRID_SIZE = calculateTileSize(selectedSize);
            
            mazeGrid = Array(ROWS).fill(0).map(() => Array(COLS).fill(1));
            
            const container = document.getElementById('maze-container');
            // Set container dimensions dynamically based on calculated size
            container.style.width = `${COLS * GRID_SIZE}px`;
            container.style.height = `${ROWS * GRID_SIZE}px`;
            container.style.gridTemplateColumns = `repeat(${COLS}, ${GRID_SIZE}px)`;
            container.style.gridTemplateRows = `repeat(${ROWS}, ${GRID_SIZE}px)`;
            container.innerHTML = '';
            
            isMouseDown = false;
            lastCell = null;
            
            // Hide modal on initialization
            hideWinModal();
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.setAttribute('data-index', coordsToId(r, c));
                    cell.setAttribute('data-r', r);
                    cell.setAttribute('data-c', c);
                    container.appendChild(cell);
                    
                    // Mouse/Touch Listeners
                    cell.addEventListener('mousedown', handleMoveStart);
                    cell.addEventListener('mouseenter', handleMove);
                    
                    // CHANGED: {passive: true} to {passive: false} to allow e.preventDefault()
                    cell.addEventListener('touchstart', handleMoveStart, {
                        passive: false
                    });
                    
                    cell.addEventListener('touchmove', handleTouchMove, {
                        passive: false
                    });
                }
            }
            
            // Listeners for stopping drag/touch outside the maze
            document.addEventListener('mouseup', handleMoveEnd);
            document.addEventListener('touchend', handleMoveEnd);
            document.addEventListener('touchcancel', handleMoveEnd);
        }
        
        function updateCellVisual(r, c, type) {
            const index = coordsToId(r, c);
            const cell = document.querySelector(`[data-index="${index}"]`);
            
            if (!cell) return;
            
            // Reset all path/status classes before adding the new one
            cell.classList.remove('path', 'start', 'end', 'solution', 'explored', 'user-path');
            
            if (type === 'wall') {
                // Already has 'cell' class, no other class needed for wall
            } else if (type === 'path') {
                cell.classList.add('path');
            } else if (type === 'start') {
                cell.classList.add('path', 'start');
            } else if (type === 'end') {
                cell.classList.add('path', 'end');
            } else if (type === 'solution') {
                cell.classList.add('path', 'solution');
            } else if (type === 'explored') {
                cell.classList.add('path', 'explored');
            } else if (type === 'user-path') {
                cell.classList.add('path', 'user-path');
            }
        }
        
        // --- Maze Generation (Prim's Algorithm) ---
        
        function generateMaze() {
            // Ensure initialization runs before generation
            initializeGrid();
            
            const startR = 1;
            const startC = 1;
            mazeGrid[startR][startC] = 0;
            
            let wallList = [];
            const directions = [
                [-2, 0],
                [0, 2],
                [2, 0],
                [0, -2]
            ];
            
            // Initial wall setup
            for (const [dr, dc] of directions) {
                const wr = startR + dr / 2;
                const wc = startC + dc / 2;
                
                if (wr > 0 && wr < ROWS - 1 && wc > 0 && wc < COLS - 1) {
                    wallList.push({
                        r: wr,
                        c: wc,
                        nr: startR + dr,
                        nc: startC + dc
                    });
                }
            }
            
            // Prim's algorithm
            while (wallList.length > 0) {
                const wallIndex = Math.floor(Math.random() * wallList.length);
                const wall = wallList[wallIndex];
                
                const wr = wall.r;
                const wc = wall.c;
                const nr = wall.nr;
                const nc = wall.nc;
                
                // Check if neighbor (nr, nc) is an unvisited wall
                if (nr > 0 && nr < ROWS - 1 && nc > 0 && nc < COLS - 1 && mazeGrid[nr][nc] === 1) {
                    
                    // Knock down the wall and carve the path to the neighbor
                    mazeGrid[wr][wc] = 0;
                    mazeGrid[nr][nc] = 0;
                    
                    // Add the neighbor's surrounding walls to the list
                    for (const [n_dr, n_dc] of directions) {
                        const new_wr = nr + n_dr / 2;
                        const new_wc = nc + n_dc / 2;
                        const neighborNeighborR = nr + n_dr;
                        const neighborNeighborC = nc + n_dc;
                        
                        if (neighborNeighborR > 0 && neighborNeighborR < ROWS - 1 &&
                            neighborNeighborC > 0 && neighborNeighborC < COLS - 1 &&
                            mazeGrid[neighborNeighborR][neighborNeighborC] === 1) {
                            
                            wallList.push({
                                r: new_wr,
                                c: new_wc,
                                nr: neighborNeighborR,
                                nc: neighborNeighborC
                            });
                        }
                    }
                }
                
                // Remove the current wall from the list
                wallList.splice(wallIndex, 1);
            }
            
            // Set Start (2) and End (3) points
            mazeGrid[1][1] = 2;
            mazeGrid[ROWS - 2][COLS - 2] = 3;
            
            renderMaze();
        }
        
        function renderMaze() {
            // Initial rendering of the static maze structure
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const value = mazeGrid[r][c];
                    let type = 'wall';
                    if (value === 0) type = 'path';
                    if (value === 2) type = 'start';
                    if (value === 3) type = 'end';
                    if (value === 4) type = 'solution';
                    
                    updateCellVisual(r, c, type);
                }
            }
        }
        
        // --- Maze Solver (Breadth-First Search - BFS) ---
        
        function visualizeExploration(cellsToDraw) {
            return new Promise(resolve => {
                // Use requestAnimationFrame to ensure smooth visual updates
                requestAnimationFrame(() => {
                    for (const [r, c] of cellsToDraw) {
                        // Avoid overwriting start/end visuals
                        if (mazeGrid[r][c] !== 2 && mazeGrid[r][c] !== 3) {
                            updateCellVisual(r, c, 'explored');
                        }
                    }
                    resolve();
                });
            });
        }
        
        async function solveMaze() {
            if (isSolving) return;
            isSolving = true;
            
            // Clear previous solution/user path visuals
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    // Reset solution (4), user path (userPath holds coords), and explored paths
                    if (mazeGrid[r][c] === 4) mazeGrid[r][c] = 0;
                    
                    // Clear visual paths
                    const type = (mazeGrid[r][c] === 2) ? 'start' : (mazeGrid[r][c] === 3) ? 'end' : (mazeGrid[r][c] === 1) ? 'wall' : 'path';
                    updateCellVisual(r, c, type);
                }
            }
            
            // Re-render the userPath if any exists before solving begins, 
            // but the BFS will clear/overwrite it anyway.
            userPath = [];
            
            const start = [1, 1];
            const end = [ROWS - 2, COLS - 2];
            const queue = [start];
            const cameFrom = {};
            cameFrom[`${start[0]},${start[1]}`] = null;
            const directions = [
                [0, 1],
                [0, -1],
                [1, 0],
                [-1, 0]
            ];
            let found = false;
            const visitedCells = [];
            
            // Optimization for visualization speed
            const MAX_STEPS_PER_FRAME = (ROWS > 41) ? 50 : 20;
            let stepCount = 0;
            let frameUpdateQueue = [];
            
            while (queue.length > 0 && !found) {
                const [r, c] = queue.shift();
                
                visitedCells.push([r, c]);
                frameUpdateQueue.push([r, c]);
                stepCount++;
                
                // Throttle visualization updates based on MAX_STEPS_PER_FRAME
                if (stepCount >= MAX_STEPS_PER_FRAME || (r === end[0] && c === end[1])) {
                    await visualizeExploration(frameUpdateQueue);
                    frameUpdateQueue = [];
                    stepCount = 0;
                }
                
                if (r === end[0] && c === end[1]) {
                    found = true;
                    break;
                }
                
                for (const [dr, dc] of directions) {
                    const nr = r + dr;
                    const nc = c + dc;
                    const neighborKey = `${nr},${nc}`;
                    
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS &&
                        mazeGrid[nr][nc] !== 1 && !(neighborKey in cameFrom)) {
                        
                        cameFrom[neighborKey] = [r, c];
                        queue.push([nr, nc]);
                    }
                }
            }
            
            // Final visualization update
            if (frameUpdateQueue.length > 0) {
                await visualizeExploration(frameUpdateQueue);
            }
            
            // --- Solution Reconstruction ---
            if (found) {
                let current = end;
                const path = [];
                while (current) {
                    path.push(current);
                    const key = `${current[0]},${current[1]}`;
                    current = cameFrom[key];
                }
                path.reverse();
                
                // Clear all temporary 'explored' marks (must be done quickly)
                for (const [r, c] of visitedCells) {
                    if (mazeGrid[r][c] !== 2 && mazeGrid[r][c] !== 3 && mazeGrid[r][c] !== 1) {
                        updateCellVisual(r, c, 'path');
                    }
                }
                
                // Draw the final solution path
                for (const [r, c] of path) {
                    if (mazeGrid[r][c] === 0) {
                        mazeGrid[r][c] = 4; // Mark as solution in the data
                        updateCellVisual(r, c, 'solution');
                    }
                }
            } else {
                // If BFS fails (shouldn't happen with Prim's generation)
                alert("No path found!");
            }
            
            // Restore start/end visuals in case they were temporary cleared/overwritten
            updateCellVisual(start[0], start[1], 'start');
            updateCellVisual(end[0], end[1], 'end');
            
            isSolving = false;
        }
        
        // --- Win Modal Functions ---
        
        function showWinModal() {
            const modal = document.getElementById('win-modal-overlay');
            const messages = WIN_MESSAGES[ROWS];
            
            document.getElementById('modal-title').textContent = messages.title;
            document.getElementById('modal-message').textContent = messages.message;
            
            // Add 'active' class to trigger CSS transition/display
            modal.classList.add('active');
            
            // Disable document scrolling while modal is open
            document.body.style.overflow = 'hidden';
        }
        
        function hideWinModal() {
            const modal = document.getElementById('win-modal-overlay');
            modal.classList.remove('active');
            
            // Re-enable document scrolling
            document.body.style.overflow = '';
        }
        
        // --- User Solving Functions ---
        
        function getCoordsFromEvent(e) {
            const cell = e.target.closest('.cell');
            if (cell) {
                return {
                    r: parseInt(cell.dataset.r),
                    c: parseInt(cell.dataset.c)
                };
            }
            return null;
        }
        
        function handleUserMove(r, c) {
            if (isSolving) return;
            
            const [startR, startC] = [1, 1];
            const [endR, endC] = [ROWS - 2, COLS - 2];
            const currentCoords = [r, c];
            
            // 1. Path Start
            if (userPath.length === 0) {
                if (r === startR && c === startC) {
                    userPath.push(currentCoords);
                    lastCell = currentCoords;
                }
                return;
            }
            
            // Find if the current cell is already in the path (for backtracking/taps)
            const existingIndex = userPath.findIndex(cell => cell[0] === r && cell[1] === c);
            
            // 2. Backtracking/Clearing (New Functionality)
            if (existingIndex !== -1) {
                // If the user taps a cell already in the path, trim the path to that cell.
                // This is a powerful feature for escaping dead ends without redrawing backward.
                if (existingIndex < userPath.length - 1) {
                    // Cells to clear visually
                    const cellsToClear = userPath.slice(existingIndex + 1);
                    
                    cellsToClear.forEach(([cr, cc]) => {
                        // Clear visual path, unless it's the end cell
                        if (cr !== endR || cc !== endC) {
                            updateCellVisual(cr, cc, 'path');
                        }
                    });
                    
                    // Trim the path array
                    userPath.splice(existingIndex + 1);
                    lastCell = userPath[userPath.length - 1];
                }
                return;
            }
            
            // 3. New Move (Only check adjacency and wall status against the last cell)
            const [pr, pc] = userPath[userPath.length - 1];
            
            const isAdjacent = Math.abs(r - pr) + Math.abs(c - pc) === 1;
            const isPath = mazeGrid[r][c] !== 1; // Not a wall
            
            if (!isAdjacent || !isPath) {
                return;
            }
            
            // 4. Record New Move
            userPath.push(currentCoords);
            
            if (r === endR && c === endC) {
                // --- WIN CONDITION ---
                updateCellVisual(r, c, 'end');
                isMouseDown = false; // Stop drag
                
                // Show the custom modal instead of alert
                setTimeout(showWinModal, 50);
                
            } else {
                if (r !== startR || c !== startC) {
                    updateCellVisual(r, c, 'user-path');
                }
            }
            lastCell = currentCoords;
        }
        
        // --- Mouse/Touch Event Handlers ---
        
        function handleMoveStart(e) {
            if (e.button === 0 || e.type.startsWith('touch')) {
                let coords = null;
                let isSingleTouch = false;
                
                if (e.type === 'touchstart') {
                    // CRUCIAL: Only start drawing on a single finger touch (allow multi-touch for zoom)
                    if (e.touches.length > 1) {
                        isMouseDown = false;
                        return;
                    }
                    isSingleTouch = true;
                    
                    // Get coords from the first touch point's target
                    const touch = e.touches[0];
                    const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                    const cell = targetElement ? targetElement.closest('.cell') : null;
                    if (cell) {
                        coords = {
                            r: parseInt(cell.dataset.r),
                            c: parseInt(cell.dataset.c)
                        };
                    }
                } else {
                    coords = getCoordsFromEvent(e);
                }
                
                if (coords) {
                    handleUserMove(coords.r, coords.c);
                    
                    // Prevent the default touch action (scrolling/panning) only after confirming 
                    // a single-finger interaction started in a cell.
                    if (isSingleTouch) {
                        e.preventDefault();
                    }
                    isMouseDown = true;
                    lastCell = [coords.r, coords.c];
                }
            }
        }
        
        function handleMove(e) {
            if (!isMouseDown) return;
            
            const coords = getCoordsFromEvent(e);
            if (coords) {
                // Skip if we are on the same cell to prevent unnecessary processing/re-drawing
                if (lastCell && lastCell[0] === coords.r && lastCell[1] === coords.c) return;
                
                handleUserMove(coords.r, coords.c);
            }
        }
        
        function handleTouchMove(e) {
            if (!isMouseDown) return;
            
            // Prevent scrolling on touch devices while dragging (crucial for mobile responsiveness)
            e.preventDefault();
            
            const touch = e.touches[0];
            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
            const cell = targetElement ? targetElement.closest('.cell') : null;
            
            if (cell) {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                
                // Only process move if the target cell is different from the last one
                if (!lastCell || lastCell[0] !== r || lastCell[1] !== c) {
                    handleUserMove(r, c);
                }
            }
        }
        
        function handleMoveEnd() {
            isMouseDown = false;
            lastCell = null;
        }
        
        // --- Event Listeners and Initial Load 
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            // Regenerate the maze to recalculate the optimal cell size
            resizeTimeout = setTimeout(generateMaze, 200);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('difficulty').addEventListener('change', generateMaze);
            document.getElementById('generate-button').addEventListener('click', generateMaze);
            document.getElementById('solve-button').addEventListener('click', solveMaze);
            
            // Listener for the modal close button
            document.getElementById('close-modal-btn').addEventListener('click', hideWinModal);
            
            generateMaze();
        });
    </script>
</body>

</html>