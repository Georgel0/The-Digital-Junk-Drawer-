<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>The World's Hardest Game</title>
 <script src="https://cdn.tailwindcss.com"></script>
 <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
 <style>
  :root {
   --color-bg: #181818;
   --color-panel: #2a2a2a;
   --color-border: #555;
   --color-player: #ff3333;
   --color-enemy: #0044ff;
   --color-collectible: #ffd700;
   --color-goal: #32cd32;
   --color-text: #ffffff;
  }
  
  * {
   box-sizing: border-box;
   touch-action: manipulation;
  }
  
  html,
  body {
   user-select: none;
   -webkit-user-select: none;
   -moz-user-select: none;
   -ms-user-select: none;
   -webkit-user-drag: none;
  }
  
  body {
   background-color: var(--color-bg);
   color: var(--color-text);
   font-family: 'Press Start 2P', monospace;
   display: flex;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   min-height: 100vh;
   margin: 0;
   padding: 10px;
   overflow: hidden;
  }
  
  .game-wrapper {
   position: relative;
   width: 100%;
   max-width: 640px;
   box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
   border: 4px solid #888;
   border-radius: 4px;
   background-color: #000;
   transition: border-color 0.1s, box-shadow 0.1s;
  }
  
  @keyframes impact-shake {
   0% {
    transform: translate(1px, 1px) rotate(0deg);
   }
   
   10% {
    transform: translate(-1px, -2px) rotate(-1deg);
   }
   
   20% {
    transform: translate(-3px, 0px) rotate(1deg);
   }
   
   30% {
    transform: translate(3px, 2px) rotate(0deg);
   }
   
   40% {
    transform: translate(1px, -1px) rotate(1deg);
   }
   
   50% {
    transform: translate(-1px, 2px) rotate(-1deg);
   }
   
   60% {
    transform: translate(-3px, 1px) rotate(0deg);
   }
   
   70% {
    transform: translate(3px, 1px) rotate(-1deg);
   }
   
   80% {
    transform: translate(-1px, -1px) rotate(1deg);
   }
   
   90% {
    transform: translate(1px, 2px) rotate(0deg);
   }
   
   100% {
    transform: translate(1px, -2px) rotate(-1deg);
   }
  }
  
  .game-wrapper.impact {
   animation: impact-shake 0.3s ease-in-out;
   border-color: #ff3333;
   box-shadow: 0 0 30px #ff3333;
  }
  
  canvas {
   display: block;
   width: 100%;
   height: auto;
   background-color: #eeeeee;
   image-rendering: pixelated;
  }
  
  .hud {
   background-color: var(--color-panel);
   border-top: 4px solid #888;
   padding: 12px;
   display: flex;
   justify-content: space-between;
   font-size: 0.7rem;
   text-shadow: 2px 2px #000;
   text-transform: uppercase;
  }
  
  h1.title {
   color: var(--color-collectible);
   text-shadow: 3px 3px 0px #000;
   font-size: 1.5rem;
   margin-bottom: 1.5rem;
   text-align: center;
   line-height: 1.4;
  }
  
  .d-pad {
   display: grid;
   grid-template-areas:
    ". up ."
    "left . right"
    ". down .";
   gap: 8px;
   margin-top: 20px;
   width: 100%;
   max-width: 280px;
  }
  
  .d-btn {
   background-color: #444;
   border: 2px solid #888;
   border-bottom: 6px solid #222;
   border-radius: 8px;
   color: #fff;
   font-size: 1.5rem;
   padding: 15px 0;
   cursor: pointer;
   user-select: none;
   transition: transform 0.1s, border-bottom 0.1s;
  }
  
  .d-btn:active {
   transform: translateY(4px);
   border-bottom: 2px solid #222;
  }
  
  .d-up {
   grid-area: up;
  }
  
  .d-left {
   grid-area: left;
  }
  
  .d-right {
   grid-area: right;
  }
  
  .d-down {
   grid-area: down;
  }
  
  @media (min-width: 769px) {
   .d-pad {
    display: none;
   }
  }
  
  .modal-overlay {
   position: fixed;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: rgba(0, 0, 0, 0.85);
   display: none;
   flex-direction: column;
   align-items: center;
   justify-content: center;
   z-index: 100;
  }
  
  .modal-content {
   background: var(--color-panel);
   border: 4px solid var(--color-collectible);
   padding: 2rem;
   text-align: center;
   max-width: 90%;
   box-shadow: 0 0 30px var(--color-collectible);
  }
  
  .modal-title {
   font-size: 1.2rem;
   color: var(--color-player);
   margin-bottom: 1rem;
  }
  
  .modal-text {
   font-size: 0.8rem;
   line-height: 1.5;
   margin-bottom: 2rem;
   color: #ccc;
  }
  
  .btn-action {
   background-color: var(--color-goal);
   border: 2px solid #fff;
   color: #fff;
   font-family: inherit;
   padding: 10px 20px;
   font-size: 0.9rem;
   cursor: pointer;
   text-transform: uppercase;
   box-shadow: 0 4px 0 #006400;
  }
  
  .btn-action:active {
   box-shadow: 0 0 0;
   transform: translateY(4px);
  }
 </style>
 
 <!-- Vercel Web Analytics -->
 <script>
  window.va = window.va || function() {
   (window.vaq = window.vaq || []).push(arguments); };
 </script>
 <script defer src="/_vercel/insights/script.js"></script>
</head>

<body>
 
 <h1 class="title">THE WORLD'S<br>HARDEST GAME</h1>
 
 <div class="game-wrapper">
  <canvas id="gameCanvas" width="600" height="400"></canvas>
  <div class="hud">
   <span id="levelDisplay">LEVEL: 1</span>
   <span id="timerDisplay">TIME:</span>
   <span id="livesDisplay">LIVES: 3</span>
  </div>
 </div>
 
 <div class="d-pad">
  <button class="d-btn d-up" data-key="up">▲</button>
  <button class="d-btn d-left" data-key="left">◀</button>
  <button class="d-btn d-right" data-key="right">▶</button>
  <button class="d-btn d-down" data-key="down">▼</button>
 </div>
 
 <div id="modalOverlay" class="modal-overlay">
  <div class="modal-content">
   <div id="modalTitle" class="modal-title"></div>
   <div id="modalText" class="modal-text"></div>
   <button id="modalBtn" class="btn-action"></button>
  </div>
 </div>
 <script>
  //STATE OBJECT 
  const game = {
   // CONFIG
   W: 600, //Width
   H: 400, //Height 
   P_SIZE: 18, //Player Size
   E_SIZE: 10, //Enemies Size
   C_SIZE: 8, //Coins Size
   P_SPEED: 2.5, //Player Speed
   SAFE_W: 70, //Safe Zone Width
   SPEED_MODERATE: 2.5,
   SPEED_FAST: 5.0,
   E_RANDOM_PROB: 0.03,
   PARTICLE_COUNT: 20,
   PARTICLE_MAX_LIFE: 30,
   PARTICLE_SPEED: 8,
   
   // COLORS
   COLOR: {
    BG: '#EEEEEE',
    SAFE_ZONE: '#B0E57C',
    PLAYER: '#FF0000',
    ENEMY: '#0000FF',
    COIN: '#FFD700',
    GOAL: '#32cd32',
    BORDER: '#000000'
   },
   
   // STATE
   ctx: null,
   wrapper: null,
   levelIndex: 0,
   lives: 3,
   frameCount: 0,
   isPaused: false,
   // Set used for fast key checks
   keys: new Set(),
   player: { x: 0, y: 0, hasCollectedAll: false },
   explosions: [],
   
   //TIME STATE VARIABLES
   levelTime: 0,
   levelTimerId: null,
   isTimerRunning: false,
   allLevelTimes: [],
   bestTimes: [],
  };
  
  // KEY MAPPING
  const KEY_MAP = {
   'arrowup': 'up',
   'w': 'up',
   'arrowdown': 'down',
   's': 'down',
   'arrowleft': 'left',
   'a': 'left',
   'arrowright': 'right',
   'd': 'right'
  };
  
  // MAIN FUNCTIONS 
  
  // Functional Particle Constructor
  const createParticle = (x, y) => {
   const angle = Math.random() * Math.PI * 2;
   const speed = Math.random() * game.PARTICLE_SPEED + 1;
   
   return {
    x,
    y,
    size: Math.random() * 4 + 1,
    life: game.PARTICLE_MAX_LIFE,
    dx: Math.cos(angle) * speed,
    dy: Math.sin(angle) * speed
   };
  };
  
  // Enemy Helper
  const initEnemyDirection = (enemy, speed) => {
   let newDx = Math.floor(Math.random() * 3) - 1;
   let newDy = Math.floor(Math.random() * 3) - 1;
   if (newDx === 0 && newDy === 0) {
    if (Math.random() < 0.5) newDx = (Math.random() < 0.5) ? 1 : -1;
    else newDy = (Math.random() < 0.5) ? 1 : -1;
   }
   enemy.dx = newDx * speed;
   enemy.dy = newDy * speed;
  };
  
  // Level Factory
  const createEnemies = (startX, startY, count, speed) => {
   const enemies = [];
   for (let i = 0; i < count; i++) {
    const enemy = { x: startX + Math.random() * 200, y: startY + Math.random() * 200, dx: 0, dy: 0 };
    initEnemyDirection(enemy, speed);
    enemies.push(enemy);
   }
   return enemies;
  };
  
  // LEVELS DATA
  const levels = [
   // Level 1 Easy
   { start: { x: game.SAFE_W - 20, y: game.H / 2 }, goal: { x: game.W - 30, y: game.H / 2, fullWall: true }, coins: [{ x: 300, y: 200, active: true }], enemies: createEnemies(100, 100, 2, game.SPEED_MODERATE) },
   // Level 2 Normal 
   { start: { x: game.SAFE_W - 20, y: 60 }, goal: { x: game.W - 30, y: game.H - 30, fullWall: false }, coins: [{ x: 150, y: 340, active: true }, { x: 450, y: 60, active: true }], enemies: createEnemies(100, 100, 4, game.SPEED_MODERATE) },
   // Level 3 Middle 
   { start: { x: game.SAFE_W - 20, y: game.H / 2 }, goal: { x: game.W - 30, y: game.H / 2, fullWall: true }, coins: [{ x: 300, y: 200, active: true }], enemies: createEnemies(100, 100, 6, game.SPEED_MODERATE) },
   // Level 4 Hard
   { start: { x: game.SAFE_W - 20, y: 60 }, goal: { x: game.W - 30, y: game.H - 30, fullWall: false }, coins: [{ x: 300, y: 200, active: true }], enemies: createEnemies(100, 100, 8, game.SPEED_MODERATE) },
   // Level 5 Insane -Developer's best-
   { start: { x: game.SAFE_W - 20, y: game.H / 2 }, goal: { x: game.W - 30, y: game.H / 2, fullWall: true }, coins: [{ x: 300, y: 200, active: true }], enemies: createEnemies(100, 100, 8, game.SPEED_FAST) },
   // Level 6 Impossible 
   { start: { x: game.SAFE_W - 20, y: 60 }, goal: { x: game.W - 30, y: game.H - 30, fullWall: false }, coins: [{ x: 300, y: 200, active: true }], enemies: createEnemies(100, 100, 10, game.SPEED_FAST) }
  ];
  
  //GAME LOGIC
  
  function draw() {
   const { ctx, COLOR, W, H, SAFE_W, P_SIZE, E_SIZE, C_SIZE, player, explosions, frameCount, levelIndex } = game;
   const level = levels[levelIndex];
   
   ctx.clearRect(0, 0, W, H);
   ctx.fillStyle = COLOR.BG;
   ctx.fillRect(0, 0, W, H);
   
   // Start Zone
   ctx.fillStyle = COLOR.SAFE_ZONE;
   ctx.fillRect(0, 0, SAFE_W, H);
   
   // Goal Zone
   let goalColor = player.hasCollectedAll ? ((Math.sin(frameCount * 0.1) > 0) ? '#FFFFFF' : '#00FF00') : '#A0D56C';
   ctx.fillStyle = goalColor;
   
   if (level.goal.fullWall) {
    ctx.fillRect(W - SAFE_W, 0, SAFE_W, H);
   } else {
    ctx.fillRect(level.goal.x - 30, level.goal.y - 30, 60, 60);
   }
   
   // Border
   ctx.strokeStyle = COLOR.BORDER;
   ctx.lineWidth = 4;
   ctx.strokeRect(0, 0, W, H);
   
   // Coins
   level.coins.forEach(coin => {
    if (coin.active) {
     ctx.beginPath();
     ctx.arc(coin.x, coin.y, C_SIZE, 0, Math.PI * 2);
     ctx.fillStyle = COLOR.COIN;
     ctx.fill();
     ctx.strokeStyle = '#000';
     ctx.lineWidth = 2;
     ctx.stroke();
     ctx.closePath();
    }
   });
   
   // Enemies
   level.enemies.forEach(enemy => {
    ctx.beginPath();
    ctx.arc(enemy.x, enemy.y, E_SIZE, 0, Math.PI * 2);
    ctx.fillStyle = COLOR.ENEMY;
    ctx.fill();
    ctx.closePath();
   });
   
   // Player (Hide if exploding)
   if (!explosions.length || game.isPaused) {
    ctx.fillStyle = COLOR.PLAYER;
    const pHalf = P_SIZE / 2;
    ctx.fillRect(player.x - pHalf, player.y - pHalf, P_SIZE, P_SIZE);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - pHalf, player.y - pHalf, P_SIZE, P_SIZE);
   }
   
   // Explosions
   explosions.forEach(p => {
    const alpha = p.life / game.PARTICLE_MAX_LIFE;
    ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
   });
   
   // HUD / Messages
   if (player.hasCollectedAll) {
    ctx.font = '20px "Press Start 2P"';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.textAlign = "center";
    if (Math.floor(frameCount / 30) % 2 === 0) {
     ctx.fillText("GO TO GREEN ZONE!", W / 2, H / 2);
    }
   }
  }
  
  function update() {
   game.frameCount++;
   const level = levels[game.levelIndex];
   const { player, keys, P_SPEED, P_SIZE, E_SIZE, SAFE_W, W, H, E_RANDOM_PROB } = game;
   
   // Update Explosions
   game.explosions = game.explosions.filter(p => {
    p.x += p.dx;
    p.y += p.dy;
    p.dx *= 0.95;
    p.dy *= 0.95;
    p.life--;
    return p.life > 0;
   });
   
   if (game.isPaused) return;
   
   //Timer start logic
   if (!game.isTimerRunning && player.x > game.SAFE_W && game.levelTimerId === null) {
    startLevelTimer();
   }
   
   // Move Player
   let dx = 0,
    dy = 0;
   if (keys.has('up')) dy -= P_SPEED;
   if (keys.has('down')) dy += P_SPEED;
   if (keys.has('left')) dx -= P_SPEED;
   if (keys.has('right')) dx += P_SPEED;
   
   player.x += dx;
   player.y += dy;
   
   const pRadius = P_SIZE / 2;
   player.x = Math.max(pRadius, Math.min(W - pRadius, player.x));
   player.y = Math.max(pRadius, Math.min(H - pRadius, player.y));
   
   // Move Enemies
   const boundaryL = SAFE_W;
   const boundaryR = W - SAFE_W;
   const currentSpeed = (game.levelIndex >= 4) ? game.SPEED_FAST : game.SPEED_MODERATE;
   
   level.enemies.forEach(enemy => {
    // Reflection from boundary
    if (enemy.x + E_SIZE >= boundaryR || enemy.x - E_SIZE <= boundaryL) {
     enemy.dx *= -1;
     enemy.x = enemy.x <= boundaryL + E_SIZE ? boundaryL + E_SIZE + 1 : boundaryR - E_SIZE - 1;
    }
    if (enemy.y + E_SIZE >= H || enemy.y - E_SIZE <= 0) {
     enemy.dy *= -1;
     enemy.y = enemy.y <= E_SIZE ? E_SIZE + 1 : H - E_SIZE - 1;
    }
    
    // Random direction change
    if (Math.random() < E_RANDOM_PROB) {
     initEnemyDirection(enemy, currentSpeed);
    }
    
    enemy.x += enemy.dx;
    enemy.y += enemy.dy;
   });
   
   checkCollisions(level);
  }
  
  function startLevelTimer() {
   if (game.isTimerRunning) return; // prevent double starting
   
   game.isTimerRunning = true;
   game.levelTimerId = setInterval(() => {
    game.levelTime += 10;
    updateHUD();
   }, 10);
  }
  
  function stopLevelTimer() {
   clearInterval(game.levelTimerId);
   game.levelTimerId = null;
   game.isTimerRunning = false;
  }
  
  function checkCollisions(level) {
   const { player, P_SIZE, E_SIZE, C_SIZE, W, H } = game;
   
   //Coins
   let coinsActive = 0;
   level.coins.forEach(coin => {
    if (coin.active) {
     const dist = Math.hypot(player.x - coin.x, player.y - coin.y);
     if (dist < (P_SIZE / 2 + C_SIZE)) coin.active = false;
     else coinsActive++;
    }
   });
   player.hasCollectedAll = (coinsActive === 0);
   
   //Enemies
   for (let enemy of level.enemies) {
    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
    if (dist < (P_SIZE / 2 + E_SIZE - 2)) {
     handleDeath();
     return;
    }
   }
   
   //Goal
   if (player.hasCollectedAll) {
    const g = level.goal;
    const gLeft = g.fullWall ? (W - game.SAFE_W) : (g.x - 30);
    const gRight = g.fullWall ? W : (g.x + 30);
    const gTop = g.fullWall ? 0 : (g.y - 30);
    const gBottom = g.fullWall ? H : (g.y + 30);
    
    if (player.x > gLeft && player.x < gRight && player.y > gTop && player.y < gBottom) {
     handleLevelComplete();
    }
   }
  }
  
  // GAME FLOW & UI
  
  function updateHUD() {
   document.getElementById('levelDisplay').textContent = `LEVEL: ${game.levelIndex + 1} / ${levels.length}`;
   document.getElementById('livesDisplay').textContent = `LIVES: ${game.lives}`;
   
   const timeInSeconds = (game.levelTime / 1000).toFixed(2);
   const timerDisplay = document.getElementById('timerDisplay');
   timerDisplay.textContent = `TIME: ${timeInSeconds}s`;
   timerDisplay.style.cursor = 'pointer';
   timerDisplay.onclick = displayAllLevelTimes;
  }
  
  function handleDeath() {
   game.lives--;
   updateHUD();
   game.isPaused = true;
   
   // CSS Impact
   game.wrapper.classList.add('impact');
   setTimeout(() => game.wrapper.classList.remove('impact'), 300);
   
   // JS Particles
   for (let i = 0; i < game.PARTICLE_COUNT; i++) {
    game.explosions.push(createParticle(game.player.x, game.player.y));
   }
   
   // Clear input
   game.keys.clear();
   
   stopLevelTimer();
   
   // Explosion Timing (Promise pattern for cleaner flow)
   const EXPLOSION_DELAY = game.PARTICLE_MAX_LIFE * 17;
   
   new Promise(resolve => setTimeout(resolve, EXPLOSION_DELAY)).then(() => {
    if (game.lives <= 0) {
     const totalTime = game.allLevelTimes.reduce((sum, item) => sum + item.time, 0);
     const totalTimeSeconds = (totalTime / 1000).toFixed(2);
     
     saveBestTime(totalTime);
     loadBestTimes();
     
     //Display total time on Game Over screen
     let finalMessage = `Your time on completed levels: ${totalTimeSeconds}s. Better luck next time.`;
     
     showModal("GAME OVER", finalMessage, "RETRY", () => {
      game.lives = 3;
      game.levelIndex = 0;
      game.allLevelTimes = [];
      loadLevel(0);
     });
    } else {
     loadLevel(game.levelIndex, false);
     game.isPaused = false;
    }
   });
  }
  
  function handleLevelComplete() {
   //Timer recording logic
   stopLevelTimer();
   game.allLevelTimes.push({
    level: game.levelIndex + 1,
    time: game.levelTime
   });
   const timeInSeconds = (game.levelTime / 1000).toFixed(2);
   game.levelTime = 0;
   
   if (game.levelIndex < levels.length - 1) {
    showModal("LEVEL COMPLETE", `Time: ${timeInSeconds}s. Go to the next challenge.`, "NEXT LEVEL", () => {
     game.levelIndex++;
     loadLevel(game.levelIndex);
    });
   } else {
    // VICTORY Logic
    const totalTime = game.allLevelTimes.reduce((sum, item) => sum + item.time, 0);
    const totalTimeSeconds = (totalTime / 1000).toFixed(2);
    
    saveBestTime(totalTime);
    loadBestTimes();
    
    let modalText = `Total Time: ${totalTimeSeconds}s. You are a true gamer.`;
    
    showModal("VICTORY", modalText, "PLAY AGAIN", () => {
     game.lives = 3;
     game.levelIndex = 0;
     game.allLevelTimes = [];
     loadLevel(0);
    });
   }
  }
  
  function loadLevel(index) {
   const level = levels[index];
   
   // Re-init enemy directions based on speed
   const speed = (index >= 4) ? game.SPEED_FAST : game.SPEED_MODERATE;
   level.enemies.forEach(e => initEnemyDirection(e, speed));
   
   game.player.x = level.start.x;
   game.player.y = level.start.y;
   game.player.hasCollectedAll = false;
   level.coins.forEach(c => c.active = true);
   
   stopLevelTimer();
   game.levelTime = 0;
   
   game.explosions = [];
   updateHUD();
  }
  
  function showModal(title, text, btnText, callback) {
   game.isPaused = true;
   game.keys.clear();
   
   const overlay = document.getElementById('modalOverlay');
   document.getElementById('modalTitle').textContent = title;
   document.getElementById('modalText').innerHTML = text;
   const btn = document.getElementById('modalBtn');
   btn.textContent = btnText;
   
   const newBtn = btn.cloneNode(true);
   btn.parentNode.replaceChild(newBtn, btn);
   
   newBtn.addEventListener('click', (event) => {
    overlay.style.display = 'none';
    game.isPaused = false;
    callback();
   }, { once: true });
   
   overlay.style.display = 'flex';
  }
  
  function loop() {
   update();
   draw();
   requestAnimationFrame(loop);
  }
  
  //Local storage and display
  const LOCAL_STORAGE_KEY = 'hardestGameBestTimes';
  
  function loadBestTimes() {
   try {
    const data = localStorage.getItem(LOCAL_STORAGE_KEY);
    game.bestTimes = data ? JSON.parse(data) : [];
   } catch (e) {
    console.error("Could not load best times from LS:", e);
    
    game.bestTimes = [];
   }
  }
  
  function saveBestTime(newTotalTime) {
   if (newTotalTime === 0) return;
   
   loadBestTimes();
   
   game.bestTimes.push({
    time: newTotalTime,
    date: new Date().toISOString().split('T')[0]
   });
   
   game.bestTimes.sort((a, b) => a.time - b.time);
   game.bestTimes = game.bestTimes.slice(0, 3);
   
   try {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(game.bestTimes));
   } catch (e) {
    console.error("Could not save to LS:", e);
   }
  }
  
  function displayAllLevelTimes() {
   if (game.isPaused) return;
   game.isPaused = true;
   game.keys.clear();
   
   let timeListHTML = '<h3>Level Times</h3><ul>';
   
   if (game.allLevelTimes.length === 0) {
    timeListHTML += '<li>No completed levels yet.</li>';
   } else {
    game.allLevelTimes.forEach(item => {
     const timeSec = (item.time / 1000).toFixed(2);
     timeListHTML += `<li>LVL ${item.level}: ${timeSec}s</li>`;
    });
   }
   timeListHTML += '</ul><hr/><h3>Top 3 Best Totals</h3><ol>';
   
   loadBestTimes();
   if (game.bestTimes.length === 0) {
    timeListHTML += '<li>No records saved yet.</li>';
   } else {
    game.bestTimes.forEach((item, index) => {
     const timeSec = (item.time / 1000).toFixed(2);
     timeListHTML += `<li>#${index + 1} (${item.date}): ${timeSec}s</li>`;
    });
   }
   timeListHTML += '</ol>';
   
   showModal(
    "TIME RECORDS",
    `<div style="font-size:0.7rem; text-align:left;">${timeListHTML}</div>`,
    "CLOSE",
    () => {}
   );
  }
  
  function init() {
   
   window.addEventListener('keydown', (event) => {
    const overlay = document.getElementById('modalOverlay');
    const btn = document.getElementById('modalBtn');
    if (event.key === 'Enter' && overlay.style.display === 'flex') {
     event.preventDefault(); 
     btn.click();
    }
   });
   
   const canvas = document.getElementById('gameCanvas');
   game.ctx = canvas.getContext('2d');
   game.wrapper = document.querySelector('.game-wrapper');
   game.ctx.imageSmoothingEnabled = false;
   
   // Unified Input Handling (Set) 
   const handleKey = (e, isDown) => {
    const key = e.key.toLowerCase();
    const mappedKey = KEY_MAP[key];
    
    if (mappedKey) {
     if (isDown) {
      game.keys.add(mappedKey);
      if (['up', 'down', 'left', 'right'].includes(mappedKey)) e.preventDefault();
     } else {
      game.keys.delete(mappedKey);
     }
    }
   };
   
   window.addEventListener('keydown', e => handleKey(e, true));
   window.addEventListener('keyup', e => handleKey(e, false));
   
   // Mobile input listeners
   const btns = document.querySelectorAll('.d-btn');
   btns.forEach(btn => {
    const key = btn.dataset.key;
    const start = (e) => { e.preventDefault();
     game.keys.add(key); };
    const end = (e) => { e.preventDefault();
     game.keys.delete(key); };
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('touchstart', start, { passive: false });
    btn.addEventListener('touchend', end);
   });
   
   loadBestTimes();
   
   loadLevel(0);
   loop();
  }
  
  window.onload = init;
 </script>
 
</body>

</html>