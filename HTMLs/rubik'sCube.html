<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <title>3D Rubik's Cube</title>
 <script src="https://cdn.tailwindcss.com"></script>
 <style>
  body {
   margin: 0;
   overflow: hidden;
   background-color: #1a1a1a;
   font-family: ui-sans-serif, system-ui, sans-serif;
   touch-action: none; /* Critical: Disables browser zooming/panning */
   user-select: none; /* Disables text selection */
   -webkit-user-select: none;
   -webkit-tap-highlight-color: transparent;
  }
  
  #canvas-container {
   width: 100vw;
   height: 100vh;
   position: absolute;
   top: 0;
   left: 0;
   z-index: 1;
   cursor: grab;
  }

  #canvas-container:active {
   cursor: grabbing;
  }
  
  #ui-container {
   position: absolute;
   bottom: 40px;
   left: 50%;
   transform: translateX(-50%);
   z-index: 10;
   display: flex;
   gap: 12px;
   background: rgba(30, 30, 30, 0.8);
   padding: 12px 20px;
   border-radius: 24px;
   backdrop-filter: blur(20px);
   border: 1px solid rgba(255, 255, 255, 0.1);
   box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
   pointer-events: auto;
  }
  
  .btn {
   background: transparent;
   color: #fff;
   padding: 8px 16px;
   border-radius: 12px;
   cursor: pointer;
   font-weight: 500;
   transition: all 0.2s;
   font-size: 0.85rem;
   border: 1px solid rgba(255, 255, 255, 0.1);
   outline: none;
   user-select: none;
  }
  
  .btn:hover {
   background: rgba(255, 255, 255, 0.1);
   border-color: rgba(255, 255, 255, 0.3);
  }
  
  .btn:active {
   transform: scale(0.95);
  }
  
  #status-panel {
   position: absolute;
   top: 25px;
   left: 25px;
   z-index: 10;
   color: #999;
   font-size: 0.75rem;
   letter-spacing: 0.05em;
   text-transform: uppercase;
   pointer-events: none;
  }
 </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
</head>

<body>
 
 <div id="status-panel">
  <h1 class="text-white font-bold text-lg mb-1 tracking-normal capitalize">Rubik's Cube</h1>
  <p>Status: <span id="status-text" class="text-white">Ready</span></p>
 </div>
 
 <div id="ui-container">
  <button id="btn-scramble" class="btn">Scramble</button>
  <button id="btn-solve" class="btn">Solve</button>
  <button id="btn-reset" class="btn">Reset</button>
 </div>
 
 <div id="canvas-container"></div>
 
 <script>
  // Configuration
  const COLORS = {
   U: 0xffffff, // White
   D: 0xffd700, // Yellow
   R: 0xc41e3a, // Red
   L: 0xff8c00, // Orange
   F: 0x009e60, // Green
   B: 0x0051ba, // Blue
   CORE: 0x111111
  };
  
  const ANIMATION_SPEED = 240;
  let scene, camera, renderer, controls;
  let cubes = [];
  let isAnimating = false;
  let moveQueue = [];
  let moveHistory = [];
  let userMoveCount = 0;
  let isScrambled = false;
  let isWaitingForScrambleEnd = false;
  
  const pivot = new THREE.Object3D();
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  
  // Interaction state
  let isCubeDragging = false;
  let touchData = {
   cube: null,
   normal: null,
   screenStart: new THREE.Vector2(),
   pointerId: null
  };
  
  function init() {
   const container = document.getElementById('canvas-container');
   
   scene = new THREE.Scene();
   scene.background = new THREE.Color(0x1a1a1a);
   
   // Camera Setup
   camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
   camera.position.set(6, 5, 8);
   scene.add(camera);
   
   renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
   renderer.setSize(window.innerWidth, window.innerHeight);
   renderer.setPixelRatio(window.devicePixelRatio);
   renderer.physicallyCorrectLights = true;
   renderer.toneMapping = THREE.ACESFilmicToneMapping;
   renderer.toneMappingExposure = 1.2;
   container.appendChild(renderer.domElement);
   
   // TrackballControls Setup
   controls = new THREE.TrackballControls(camera, renderer.domElement);
   controls.rotateSpeed = 3.5;
   controls.zoomSpeed = 1.2;
   controls.panSpeed = 0.8;
   controls.noPan = true;
   controls.staticMoving = false;
   controls.dynamicDampingFactor = 0.15;
   controls.minDistance = 4;
   controls.maxDistance = 20;
   
   // Lighting
   const ambient = new THREE.AmbientLight(0xffffff, 0.8);
   scene.add(ambient);
   const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
   hemiLight.position.set(0, 20, 0);
   scene.add(hemiLight);
   const camLight = new THREE.PointLight(0xffffff, 1.5);
   camera.add(camLight);
   const sun1 = new THREE.DirectionalLight(0xffffff, 2.5);
   sun1.position.set(10, 20, 10);
   scene.add(sun1);
   const sun2 = new THREE.DirectionalLight(0xffffff, 2.0);
   sun2.position.set(-15, -10, -15);
   scene.add(sun2);
   
   createCube();
   scene.add(pivot);
   
   setupEventInterception(renderer.domElement);
   
   window.addEventListener('resize', onWindowResize);
   document.getElementById('btn-scramble').onclick = scramble;
   document.getElementById('btn-solve').onclick = solve;
   document.getElementById('btn-reset').onclick = reset;
   
   animate();
  }
  
  // --- ROBUST EVENT INTERCEPTION SYSTEM ---
  function setupEventInterception(canvas) {
  
   // Helper to check intersection without triggering logic yet
   const checkHit = (clientX, clientY) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(cubes);
   };

   // 1. GATEKEEPER (Capture Phase)
   // This runs BEFORE TrackballControls gets the event. 
   // It decides who gets to handle the input: The Camera or The Cube Logic.
   const handleInputStart = (e) => {
    // Determine coordinates based on input type
    let clientX, clientY;
    if (e.changedTouches && e.changedTouches.length > 0) {
     clientX = e.changedTouches[0].clientX;
     clientY = e.changedTouches[0].clientY;
    } else {
     // Only accept left mouse button
     if (e.type === 'mousedown' && e.button !== 0) return;
     clientX = e.clientX;
     clientY = e.clientY;
    }

    const intersects = checkHit(clientX, clientY);

    if (intersects.length > 0) {
     // HIT A CUBE -> Disable Camera, Enable Drag
     controls.enabled = false;
     
     // IMPORTANT: We do not stop propagation here because we want our own
     // pointerdown listener (below) to receive this event to start the drag math.
     // However, setting controls.enabled = false is usually enough for Trackball.
    } else {
     // HIT BACKGROUND -> Enable Camera
     controls.enabled = true;
    }
   };

   // 2. DRAG LOGIC (Pointer Events)
   // This handles the actual math of moving the slices.
   const handlePointerDown = (e) => {
    if (e.isPrimary === false || (e.pointerType === 'mouse' && e.button !== 0)) return;
    
    // Safety check: verify hit again (fast enough) to get precise data
    const intersects = checkHit(e.clientX, e.clientY);
    
    if (intersects.length > 0) {
     isCubeDragging = true;
     controls.enabled = false; // Double ensure controls are dead
     
     const hit = intersects[0];
     const normal = hit.face.normal.clone();
     normal.applyQuaternion(hit.object.quaternion).normalize();
     
     touchData = {
      cube: hit.object,
      normal: normal,
      screenStart: new THREE.Vector2(e.clientX, e.clientY),
      pointerId: e.pointerId
     };
     
     canvas.setPointerCapture(e.pointerId);
     e.stopPropagation(); // Try to stop bubbling to be safe
    }
   };

   const handlePointerMove = (e) => {
    // If we are dragging a cube, we must prevent Trackball from seeing this move
    if (isCubeDragging) {
     e.stopImmediatePropagation(); // NUCLEAR OPTION: Kill the event locally
     e.preventDefault();
    }

    if (!isCubeDragging || isAnimating || e.pointerId !== touchData.pointerId) return;
    
    const screenPos = new THREE.Vector2(e.clientX, e.clientY);
    const delta = screenPos.clone().sub(touchData.screenStart);
    
    if (delta.length() < 10) return; // Threshold
    
    // Calculate Drag Vectors
    const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
    
    const moveDir = new THREE.Vector3()
     .addScaledVector(camRight, delta.x)
     .addScaledVector(camUp, -delta.y)
     .normalize();
    
    const rotationAxis = new THREE.Vector3().crossVectors(touchData.normal, moveDir);
    
    const worldAxes = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
    let maxDot = -1;
    let bestAxisIdx = 0;
    
    worldAxes.forEach((ax, i) => {
     const dot = Math.abs(rotationAxis.dot(ax));
     if (dot > maxDot) {
      maxDot = dot;
      bestAxisIdx = i;
     }
    });
    
    const axisChars = ['x', 'y', 'z'];
    const bestAxis = axisChars[bestAxisIdx];
    const layer = Math.round(touchData.cube.position[bestAxis]);
    
    const worldAxisVec = new THREE.Vector3();
    worldAxisVec[bestAxis] = 1;
    const dirSign = rotationAxis.dot(worldAxisVec) > 0 ? 1 : -1;
    
    queueMove(bestAxis, layer, dirSign);
    
    isCubeDragging = false;
    canvas.releasePointerCapture(e.pointerId);
    
    // Note: We don't re-enable controls here instantly to prevent jitter.
    // They will re-enable on the next pointer down on background.
   };
   
   const handlePointerUp = (e) => {
    if (isCubeDragging) {
     isCubeDragging = false;
     canvas.releasePointerCapture(e.pointerId);
    }
    // Optional: Re-enable controls on release? 
    // Usually better to leave them as-is until next touchStart logic decides.
    // But for safety:
    controls.enabled = true;
   };

   // BINDINGS
   // capture: true ensures we run BEFORE TrackballControls
   canvas.addEventListener('touchstart', handleInputStart, { capture: true, passive: false });
   canvas.addEventListener('mousedown', handleInputStart, { capture: true, passive: false });
   
   // Pointer events for the actual logic (standard bubbling/capture mix)
   canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
   canvas.addEventListener('pointermove', handlePointerMove, { passive: false, capture: true }); // Capture move to stop propagation early
   canvas.addEventListener('pointerup', handlePointerUp);
   canvas.addEventListener('pointercancel', handlePointerUp);
  }

  function createCube() {
   cubes.forEach(c => scene.remove(c));
   cubes = [];
   const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
   
   const matParams = {
    roughness: 0.12,
    metalness: 0.45,
    envMapIntensity: 1.0
   };
   
   for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
     for (let z = -1; z <= 1; z++) {
      const materials = [
       new THREE.MeshStandardMaterial({ color: x === 1 ? COLORS.R : COLORS.CORE, ...matParams }),
       new THREE.MeshStandardMaterial({ color: x === -1 ? COLORS.L : COLORS.CORE, ...matParams }),
       new THREE.MeshStandardMaterial({ color: y === 1 ? COLORS.U : COLORS.CORE, ...matParams }),
       new THREE.MeshStandardMaterial({ color: y === -1 ? COLORS.D : COLORS.CORE, ...matParams }),
       new THREE.MeshStandardMaterial({ color: z === 1 ? COLORS.F : COLORS.CORE, ...matParams }),
       new THREE.MeshStandardMaterial({ color: z === -1 ? COLORS.B : COLORS.CORE, ...matParams }),
      ];
      const mesh = new THREE.Mesh(geom, materials);
      mesh.position.set(x, y, z);
      scene.add(mesh);
      cubes.push(mesh);
     }
    }
   }
  }
  
  function queueMove(axis, layer, direction, record = true) {
   moveQueue.push({ axis, layer, direction, record });
  }
  
  function performMove(axis, layer, direction, record = true) {
   if (isAnimating) return;
   isAnimating = true;
   
   const movingCubes = cubes.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
   pivot.rotation.set(0, 0, 0);
   pivot.updateMatrixWorld();
   movingCubes.forEach(c => pivot.attach(c));
   
   const targetRotation = (Math.PI / 2) * direction;
   const startTime = performance.now();
   const duration = (moveQueue.length > 5 || !record) ? 100 : ANIMATION_SPEED;
   
   function animateStep(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const ease = 1 - Math.pow(1 - progress, 3);
    
    pivot.rotation[axis] = targetRotation * ease;
    
    if (progress < 1) {
     requestAnimationFrame(animateStep);
    } else {
     finalizeMove(movingCubes, axis, record, direction);
    }
   }
   requestAnimationFrame(animateStep);
  }
  
  function finalizeMove(movingCubes, axis, record, direction) {
   pivot.updateMatrixWorld();
   movingCubes.forEach(c => {
    scene.attach(c);
    c.position.x = Math.round(c.position.x);
    c.position.y = Math.round(c.position.y);
    c.position.z = Math.round(c.position.z);
    
    const e = new THREE.Euler().setFromQuaternion(c.quaternion);
    e.x = Math.round(e.x / (Math.PI / 2)) * (Math.PI / 2);
    e.y = Math.round(e.y / (Math.PI / 2)) * (Math.PI / 2);
    e.z = Math.round(e.z / (Math.PI / 2)) * (Math.PI / 2);
    c.quaternion.setFromEuler(e);
   });
   
   if (record) moveHistory.push({ axis, layer: Math.round(movingCubes[0].position[axis]), direction });
   if (isScrambled) {
    userMoveCount++;
    updateStatus(`${userMoveCount} Moves`);
   }
   
   isAnimating = false;
  }
  
  function scramble() {
   if (isAnimating) return;
   userMoveCount = 0;
   isScrambled = false;
   isWaitingForScrambleEnd = true;
   updateStatus("Scrambling...");
   
   const axes = ['x', 'y', 'z'];
   const layers = [-1, 0, 1];
   for (let i = 0; i < 20; i++) {
    queueMove(axes[Math.floor(Math.random() * 3)], layers[Math.floor(Math.random() * 3)], Math.random() > 0.5 ? 1 : -1);
   }
  }
  
  function solve() {
   if (moveHistory.length === 0 || isAnimating) return;
   isScrambled = false;
   isWaitingForScrambleEnd = false;
   updateStatus("Solving...");
   
   const history = [...moveHistory];
   moveHistory = [];
   history.reverse().forEach(m => queueMove(m.axis, m.layer, -m.direction, false));
   
   setTimeout(() => {
    userMoveCount = 0;
    updateStatus("Solved");
   }, (history.length * 110) + 200);
  }
  
  function reset() {
   moveQueue = [];
   moveHistory = [];
   userMoveCount = 0;
   isScrambled = false;
   isWaitingForScrambleEnd = false;
   createCube();
   controls.reset();
   updateStatus("Ready");
  }
  
  function updateStatus(txt) {
   document.getElementById('status-text').innerText = txt;
  }
  
  function onWindowResize() {
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix();
   renderer.setSize(window.innerWidth, window.innerHeight);
   controls.handleResize();
  }
  
  function animate() {
   requestAnimationFrame(animate);
   if (!isAnimating && moveQueue.length > 0) {
    const m = moveQueue.shift();
    performMove(m.axis, m.layer, m.direction, m.record);
   } else if (!isAnimating && moveQueue.length === 0 && isWaitingForScrambleEnd) {
    isWaitingForScrambleEnd = false;
    isScrambled = true;
    updateStatus("0 Moves");
   }
   
   controls.update();
   renderer.render(scene, camera);
  }
  
  window.onload = init;
 </script>
</body>
</html>